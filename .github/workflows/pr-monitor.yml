name: PR Monitor - Multi Repo (Timeline Based)

on:
  schedule:
    # Run every 5 minutes (more reliable than every minute)
    - cron: '*/5 * * * *'
  workflow_dispatch:  # Allow manual trigger for testing

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Monitor PRs across repositories
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          npm install @slack/web-api @octokit/rest
          
          node << 'EOF'
          const fs = require('fs');
          
          async function main() {
            try {
              console.log('üîç Starting PR monitoring across repositories...');
              
              const currentTime = Date.now();
              console.log(`‚è∞ Current time: ${new Date(currentTime).toISOString()}`);
              
              // Validate environment variables
              if (!process.env.GITHUB_TOKEN) {
                console.error('‚ùå GITHUB_TOKEN environment variable is required');
                process.exit(1);
              }
              
              if (!process.env.SLACK_BOT_TOKEN) {
                console.error('‚ùå SLACK_BOT_TOKEN environment variable is required');
                process.exit(1);
              }
              
              // Initialize clients
              const octokit = new (require('@octokit/rest')).Octokit({ auth: process.env.GITHUB_TOKEN });
              const slack = new (require('@slack/web-api')).WebClient(process.env.SLACK_BOT_TOKEN);
              
              // Load engineer mapping
              const mapping = JSON.parse(fs.readFileSync('engineer-github-slack-mapping.json', 'utf8'));
              
              // Repository configuration
              const repos = [
                {
                  owner: 'polkadot-developers',
                  repo: 'polkadot-docs',
                  channel: 'C07TXJZ0T3L'  // Using same channel for testing
                },
                {
                  owner: 'wormhole-foundation',
                  repo: 'wormhole-docs',
                  channel: 'C07TXJZ0T3L'
                },
                {
                  owner: 'kluster-ai',
                  repo: 'docs',
                  channel: 'C07TXJZ0T3L'
                },
                {
                  owner: 'paritytech',
                  repo: 'polkadot-sdk',
                  channel: 'C07TXJZ0T3L'
                },
                {
                  owner: 'ethereumjs',
                  repo: 'ethereumjs-monorepo',
                  channel: 'C07TXJZ0T3L'
                }
              ];
              
              console.log(`üìä Monitoring ${repos.length} repositories...`);
              
              // Get last run time from state file
              let lastRunTime = null;
              try {
                const state = JSON.parse(fs.readFileSync('/tmp/pr-monitor-state.json', 'utf8'));
                lastRunTime = state.lastRunTime ? new Date(state.lastRunTime) : null;
                console.log(`üìÇ Loaded state file`);
                console.log(`üïê Last run time: ${lastRunTime ? lastRunTime.toISOString() : 'null (first run)'}`);
              } catch (err) {
                console.log('üìù Creating new state file (first run)...');
              }
              
              const currentRunTime = new Date();
              console.log(`‚è∞ Last run: ${lastRunTime ? lastRunTime.toISOString() : 'Never'}`);
              console.log(`üöÄ Current run: ${currentRunTime.toISOString()}`);
              
              let totalNotifications = 0;
              
              // Process each repository
              for (const repoConfig of repos) {
                try {
                  console.log(`\nüìÅ Checking ${repoConfig.owner}/${repoConfig.repo}...`);
                  
                  // Get open PRs
                  const { data: pulls } = await octokit.rest.pulls.list({
                    owner: repoConfig.owner,
                    repo: repoConfig.repo,
                    state: 'open',
                    per_page: 50
                  });
                  
                  console.log(`   Found ${pulls.length} open PRs`);
                  
                  // Filter out draft PRs
                  const nonDraftPulls = pulls.filter(pr => !pr.draft);
                  console.log(`   ${nonDraftPulls.length} non-draft PRs to check`);
                  
                  for (const pr of nonDraftPulls) {
                    console.log(`\n   üîç PR #${pr.number}: "${pr.title}"`);
                    
                    // Get PR timeline to check when assignments happened
                    let timelineEvents = [];
                    try {
                      const { data: timeline } = await octokit.rest.issues.listEventsForTimeline({
                        owner: repoConfig.owner,
                        repo: repoConfig.repo,
                        issue_number: pr.number,
                        per_page: 100
                      });
                      timelineEvents = timeline;
                    } catch (err) {
                      console.error(`     ‚ùå Failed to get timeline for PR #${pr.number}:`, err.message);
                      continue;
                    }
                    
                    // Find recent assignment events (since last run or last 5 minutes for first run)
                    const cutoffTime = lastRunTime || new Date(Date.now() - 5 * 60 * 1000);
                    console.log(`     üìÖ Looking for assignments since: ${cutoffTime.toISOString()}`);
                    
                    const recentAssignmentEvents = timelineEvents.filter(event => {
                      const eventTime = new Date(event.created_at);
                      return eventTime > cutoffTime && 
                             (event.event === 'assigned' || 
                              event.event === 'review_requested');
                    });
                    
                    console.log(`     üìã Found ${recentAssignmentEvents.length} recent assignment events`);
                    
                    // Process recent assignment events and collect users to notify
                    const usersToNotify = new Set();
                    const notificationTypes = new Map(); // user -> 'assigned' or 'review_requested'
                    
                    for (const event of recentAssignmentEvents) {
                      console.log(`       Event: ${event.event} at ${event.created_at}`);
                      
                      if (event.event === 'assigned' && event.assignee) {
                        console.log(`         ‚Üí User ${event.assignee.login} was assigned`);
                        usersToNotify.add(event.assignee.login);
                        notificationTypes.set(event.assignee.login, 'assigned');
                      } else if (event.event === 'review_requested' && event.requested_reviewer) {
                        const reviewer = event.requested_reviewer.login;
                        if (reviewer) {
                          console.log(`         ‚Üí User ${reviewer} was requested to review`);
                          usersToNotify.add(reviewer);
                          notificationTypes.set(reviewer, 'review_requested');
                        }
                      }
                    }
                    
                    console.log(`     üéØ Users to notify: [${Array.from(usersToNotify).join(', ')}]`);
                    
                    // Send notifications
                    for (const username of usersToNotify) {
                      const engineer = mapping.engineers.find(e => e.github_username === username);
                      if (engineer) {
                        const notificationType = notificationTypes.get(username);
                        const isAssignment = notificationType === 'assigned';
                        const emoji = isAssignment ? 'üìù' : 'üîç';
                        const action = isAssignment ? '**assigned** to work on' : 'requested to **review**';
                        
                        try {
                          await slack.chat.postMessage({
                            channel: repoConfig.channel,
                            text: `${emoji} Hey <@${engineer.slack_id}>, you've been ${action} a PR in ${repoConfig.owner}/${repoConfig.repo}: ${pr.html_url}`
                          });
                          console.log(`       ‚úÖ Sent ${notificationType.toUpperCase()} notification to ${username} for PR #${pr.number}`);
                          totalNotifications++;
                        } catch (err) {
                          console.error(`       ‚ùå Failed to send notification to ${username}:`, err.data?.error || err.message);
                        }
                      } else {
                        console.log(`       ‚ö†Ô∏è No Slack mapping found for user ${username}`);
                      }
                    }
                  }
                  
                } catch (err) {
                  console.error(`‚ùå Error checking ${repoConfig.owner}/${repoConfig.repo}:`, err.message);
                  // Continue with other repos even if one fails
                }
              }
              
              // Save current run time for next iteration
              const newState = {
                lastRunTime: currentRunTime.toISOString()
              };
              
              fs.writeFileSync('/tmp/pr-monitor-state.json', JSON.stringify(newState, null, 2));
              console.log(`\nüíæ Saved state with current run time: ${currentRunTime.toISOString()}`);
              
              console.log(`\nüéâ Monitoring complete!`);
              console.log(`üì¢ Total notifications sent: ${totalNotifications}`);
              
            } catch (error) {
              console.error('üí• Fatal error:', error);
              process.exit(1);
            }
          }
          
          main();
          EOF