name: PR Monitor - Multi Repo

on:
  schedule:
    - cron: '*/5 * * * *'  # Runs every 5 minutes (more reliable)
  workflow_dispatch:  # Allows manual triggering

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install @octokit/rest @slack/web-api
      - name: Monitor PRs across repositories
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          node <<'EOF'
          const { Octokit } = require('@octokit/rest');
          const { WebClient } = require('@slack/web-api');
          const fs = require('fs');
          
          async function main() {
            try {
              console.log('üîç Starting PR monitoring across repositories...');
              
              const currentTime = Date.now();
              console.log(`‚è∞ Current time: ${new Date(currentTime).toISOString()}`);
              
              // Validate environment variables
              if (!process.env.GITHUB_TOKEN) {
                console.error('‚ùå GITHUB_TOKEN environment variable is required');
                process.exit(1);
              }
              
              if (!process.env.SLACK_BOT_TOKEN) {
                console.error('‚ùå SLACK_BOT_TOKEN environment variable is required');
                process.exit(1);
              }
              
              // Initialize clients
              const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
              const slack = new WebClient(process.env.SLACK_BOT_TOKEN);
              
              // Load engineer mapping
              const mapping = JSON.parse(fs.readFileSync('engineer-github-slack-mapping.json', 'utf8'));
              
              // Repository configuration
              const repos = [
                {
                  owner: 'polkadot-developers',
                  repo: 'polkadot-docs',
                  channel: 'C07TXJZ0T3L'  // Using same channel for testing
                },
                {
                  owner: 'wormhole-foundation',
                  repo: 'wormhole-docs',
                  channel: 'C07TXJZ0T3L'
                },
                {
                  owner: 'kluster-ai',
                  repo: 'docs',
                  channel: 'C07TXJZ0T3L'
                },
                {
                  owner: 'moondance-labs',
                  repo: 'tanssi-docs',
                  channel: 'C07TXJZ0T3L'
                },
                {
                  owner: 'moonbeam-foundation',
                  repo: 'moonbeam-docs',
                  channel: 'C07TXJZ0T3L'
                }
              ];
              
              console.log(`üìä Monitoring ${repos.length} repositories...`);
              
              // Get last run time from state file
              let lastRunTime = null;
              let stateFile = {};
              try {
                const state = JSON.parse(fs.readFileSync('/tmp/pr-monitor-state.json', 'utf8'));
                stateFile = state.prs || {};
                lastRunTime = state.lastRunTime ? new Date(state.lastRunTime) : null;
                console.log(`üìÇ Loaded state file with ${Object.keys(stateFile).length} PR states`);
                console.log(`üïê Last run time: ${lastRunTime ? lastRunTime.toISOString() : 'null (first run)'}`);
              } catch (err) {
                console.log('üìù Creating new state file (first run)...');
                stateFile = {};
              }
              
              const currentRunTime = new Date();
              console.log(`‚è∞ Last run: ${lastRunTime ? lastRunTime.toISOString() : 'Never'}`);
              console.log(`‚è∞ Current run: ${currentRunTime.toISOString()}`);
              
              let totalNotifications = 0;
              
              // Monitor each repository
              for (const repoConfig of repos) {
                try {
                  console.log(`\nüîç Checking ${repoConfig.owner}/${repoConfig.repo}...`);
                  
                  // Get open PRs (excluding drafts)
                  const { data: pulls } = await octokit.pulls.list({
                    owner: repoConfig.owner,
                    repo: repoConfig.repo,
                    state: 'open',
                    per_page: 50
                  });
                  
                  // Filter out draft PRs
                  const nonDraftPulls = pulls.filter(pr => !pr.draft);
                  console.log(`   üìã Found ${pulls.length} open PRs (${nonDraftPulls.length} non-draft)`);
                  
                  for (const pr of nonDraftPulls) {
                    const prKey = `${repoConfig.owner}/${repoConfig.repo}#${pr.number}`;
                    
                    // Get current reviewers and assignees
                    const currentReviewers = pr.requested_reviewers?.map(r => r.login) || [];
                    const currentAssignees = pr.assignees?.map(a => a.login) || [];
                    
                    console.log(`   üîç PR #${pr.number}: "${pr.title}"`);
                    console.log(`     Current reviewers: [${currentReviewers.join(', ')}]`);
                    console.log(`     Current assignees: [${currentAssignees.join(', ')}]`);
                    
                    // Get previous state
                    const prevState = stateFile[prKey] || { reviewers: [], assignees: [] };
                    console.log(`     Previous reviewers: [${prevState.reviewers.join(', ')}]`);
                    console.log(`     Previous assignees: [${prevState.assignees.join(', ')}]`);
                    
                    // Find new reviewers and assignees
                    const newReviewers = currentReviewers.filter(r => !prevState.reviewers.includes(r));
                    const newAssignees = currentAssignees.filter(a => !prevState.assignees.includes(a));
                    
                    console.log(`     NEW reviewers: [${newReviewers.join(', ')}]`);
                    console.log(`     NEW assignees: [${newAssignees.join(', ')}]`);
                    console.log(`     Last run time exists: ${!!lastRunTime}`);
                    
                    // Only proceed if there are new assignments AND we have a lastRunTime
                    // (Skip notifications on first run to avoid old assignments)
                    const shouldNotify = lastRunTime && (newReviewers.length > 0 || newAssignees.length > 0);
                    
                    console.log(`     Should notify: ${shouldNotify}`);
                    
                    if (!shouldNotify && (newReviewers.length > 0 || newAssignees.length > 0)) {
                      console.log(`   ‚è≠Ô∏è Skipping notifications for PR #${pr.number} (first run or no baseline)`);
                    }
                    
                    // Send notifications for new reviewers (only if not first run)
                    if (shouldNotify) {
                      for (const username of newReviewers) {
                        const engineer = mapping.engineers.find(e => e.github_username === username);
                        if (engineer) {
                          try {
                            await slack.chat.postMessage({
                              channel: repoConfig.channel,
                              text: `üîç Hey <@${engineer.slack_id}>, you've been requested to **review** a PR in ${repoConfig.owner}/${repoConfig.repo}: ${pr.html_url}`
                            });
                            console.log(`   ‚úÖ Sent REVIEW notification to ${username} for PR #${pr.number}`);
                            totalNotifications++;
                          } catch (err) {
                            console.error(`   ‚ùå Failed to send review notification to ${username}:`, err.data?.error || err.message);
                          }
                        } else {
                          console.log(`   ‚ö†Ô∏è No Slack mapping found for reviewer ${username}`);
                        }
                      }
                      
                      // Send notifications for new assignees (only if not first run)
                      for (const username of newAssignees) {
                        const engineer = mapping.engineers.find(e => e.github_username === username);
                        if (engineer) {
                          try {
                            await slack.chat.postMessage({
                              channel: repoConfig.channel,
                              text: `üìù Hey <@${engineer.slack_id}>, you've been **assigned** to work on a PR in ${repoConfig.owner}/${repoConfig.repo}: ${pr.html_url}`
                            });
                            console.log(`   ‚úÖ Sent ASSIGNMENT notification to ${username} for PR #${pr.number}`);
                            totalNotifications++;
                          } catch (err) {
                            console.error(`   ‚ùå Failed to send assignment notification to ${username}:`, err.data?.error || err.message);
                          }
                        } else {
                          console.log(`   ‚ö†Ô∏è No Slack mapping found for assignee ${username}`);
                        }
                      }
                    }
                    
                    // Update state
                    stateFile[prKey] = {
                      reviewers: currentReviewers,
                      assignees: currentAssignees,
                      lastChecked: new Date().toISOString()
                    };
                  }
                  
                } catch (err) {
                  console.error(`‚ùå Error checking ${repoConfig.owner}/${repoConfig.repo}:`, err.message);
                  // Continue with other repos even if one fails
                }
              }
              
              // Clean up old PRs from state (older than 7 days)
              const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
              for (const [prKey, prState] of Object.entries(stateFile)) {
                if (new Date(prState.lastChecked) < oneWeekAgo) {
                  delete stateFile[prKey];
                }
              }
              
              // Save state with current run time
              const newState = {
                lastRunTime: currentRunTime.toISOString(),
                prs: stateFile
              };
              fs.writeFileSync('/tmp/pr-monitor-state.json', JSON.stringify(newState, null, 2));
              
              console.log(`\nüéâ Monitoring complete! Sent ${totalNotifications} notifications across ${repos.length} repositories.`);
              
            } catch (error) {
              console.error('üí• Script error:', error);
              process.exit(1);
            }
          }
          
          main();
          EOF