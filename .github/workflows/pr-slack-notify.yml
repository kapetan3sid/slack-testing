name: PR Slack Notify

on:
  pull_request:
    types: [opened, ready_for_review, review_requested, assigned]

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: npm install @slack/web-api
      - name: Notify reviewers via Slack
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        run: |
          node <<'EOF'
          const { WebClient } = require('@slack/web-api');
          const fs = require('fs');
          
          async function main() {
            try {
              console.log('Starting Slack notification process...');
              
              if (!process.env.SLACK_BOT_TOKEN) {
                console.error('Error: SLACK_BOT_TOKEN environment variable is required');
                process.exit(1);
              }
              
              const mapping = JSON.parse(fs.readFileSync('engineer-github-slack-mapping.json', 'utf8'));
              const slack = new WebClient(process.env.SLACK_BOT_TOKEN);
              
              // Debug: Test bot authentication
              try {
                const authTest = await slack.auth.test();
                console.log('Bot authenticated as:', authTest.user, 'in workspace:', authTest.team);
              } catch (err) {
                console.error('‚ùå Auth test failed:', err.data || err.message);
                return;
              }
              
              // Get event data
              const eventPath = process.env.GITHUB_EVENT_PATH;
              const event = JSON.parse(fs.readFileSync(eventPath, 'utf8'));
              
              console.log('Event action:', event.action);
              console.log('PR URL:', event.pull_request?.html_url);
              
              // The Slack Channel - your dedicated private channel
              const CHANNEL_ID = 'C07TXJZ0T3L'; // Your private channel (bot must be invited)
              
              let reviewers = [];
              let assignees = [];
              
              // Get reviewers and assignees based on event
              if (event.action === 'review_requested' && event.requested_reviewer) {
                reviewers.push(event.requested_reviewer.login);
                console.log('Reviewer requested:', event.requested_reviewer.login);
              } else if (event.action === 'assigned' && event.assignee) {
                assignees.push(event.assignee.login);
                console.log('Assignee added:', event.assignee.login);
              } else if (event.pull_request) {
                // For opened/ready_for_review, notify all current reviewers and assignees
                if (event.pull_request.requested_reviewers) {
                  reviewers = event.pull_request.requested_reviewers.map(r => r.login);
                }
                if (event.pull_request.assignees) {
                  assignees = event.pull_request.assignees.map(a => a.login);
                }
              }
              
              // Remove duplicates
              reviewers = [...new Set(reviewers)];
              assignees = [...new Set(assignees)];
              
              console.log('Target reviewers:', reviewers);
              console.log('Target assignees:', assignees);
              
              if (reviewers.length === 0 && assignees.length === 0) {
                console.log('No target users found, skipping notifications');
                return;
              }
              
              // Send notifications to reviewers
              for (const username of reviewers) {
                const engineer = mapping.engineers.find(e => e.github_username === username);
                if (engineer) {
                  try {
                    const result = await slack.chat.postMessage({
                      channel: CHANNEL_ID,
                      text: `üîç Hey <@${engineer.slack_id}>, you've been requested to review a PR: ${event.pull_request.html_url}`
                    });
                    console.log(`‚úÖ Sent REVIEW notification to ${username} (${engineer.slack_id}) in channel ${CHANNEL_ID}:`, result.ok);
                  } catch (err) {
                    console.error(`‚ùå FAILED to send review notification to ${username} in channel ${CHANNEL_ID}:`, err.data?.error || err.message);
                    console.error('üö´ ABORTING: Cannot deliver to dedicated channel');
                    process.exit(1);
                  }
                } else {
                  console.log(`‚ö†Ô∏è No Slack mapping found for reviewer ${username}`);
                }
              }
              
              // Send notifications to assignees
              for (const username of assignees) {
                const engineer = mapping.engineers.find(e => e.github_username === username);
                if (engineer) {
                  try {
                    const result = await slack.chat.postMessage({
                      channel: CHANNEL_ID,
                      text: `üìù Hey <@${engineer.slack_id}>, you've been assigned to a PR: ${event.pull_request.html_url}`
                    });
                    console.log(`‚úÖ Sent ASSIGNMENT notification to ${username} (${engineer.slack_id}) in channel ${CHANNEL_ID}:`, result.ok);
                  } catch (err) {
                    console.error(`‚ùå FAILED to send assignment notification to ${username} in channel ${CHANNEL_ID}:`, err.data?.error || err.message);
                    console.error('üö´ ABORTING: Cannot deliver to dedicated channel');
                    process.exit(1);
                  }
                } else {
                  console.log(`‚ö†Ô∏è No Slack mapping found for assignee ${username}`);
                }
              }
            } catch (error) {
              console.error('Script error:', error);
              process.exit(1);
            }
          }
          
          main();
          EOF

