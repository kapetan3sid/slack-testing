name: PR Review Reminder

on:
  schedule:
    # Run on weekdays at 9 AM UTC (Monday-Friday)
    - cron: '0 9 * * 1-5'
  workflow_dispatch: # Allow manual triggering

jobs:
  check-inactive-reviewers:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: npm install @slack/web-api

      - name: Check PRs and send reminders
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        with:
          script: |
            const { WebClient } = require('@slack/web-api');
            const fs = require('fs');
            
            const slack = new WebClient(process.env.SLACK_BOT_TOKEN);
            
            // Special users who are checked as ASSIGNEES instead of REVIEWERS
            const ASSIGNEE_REVIEWERS = new Set(['eshaben', 'dawnkelly09', '0xlukem', 'Telucero']);
            
            // Repositories to monitor
            // Check if today is a working day (Monday-Friday)
            const today = new Date();
            const dayOfWeek = today.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            if (dayOfWeek === 0 || dayOfWeek === 6) {
              console.log('Today is a weekend. Skipping PR review reminder check.');
              return;
            }
            
            // On Mondays, check for 4 days of inactivity (to cover the weekend)
            // On other weekdays, check for 3 days
            const isMonday = dayOfWeek === 1;
            const daysToCheck = isMonday ? 4 : 3;
            const STALE_THRESHOLD_MS = daysToCheck * 24 * 60 * 60 * 1000;
            
            console.log(`Today is ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
            console.log(`Checking for inactivity over the last ${daysToCheck} days`);
            
            const REPOS = [
              { owner: 'polkadot-developers', repo: 'polkadot-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'wormhole-foundation', repo: 'wormhole-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'kluster-ai', repo: 'docs', channel: 'C07TXJZ0T3L' },
              { owner: 'moondance-labs', repo: 'tanssi-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'moonbeam-foundation', repo: 'moonbeam-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'datahaven-xyz', repo: 'datahaven-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'kluster-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'polkadot-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'wormhole-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'datahaven-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'tanssi-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'moonbeam-mkdocs', channel: 'C07TXJZ0T3L' }
            ];
            
            // Load engineer mappings
            const engineerData = JSON.parse(fs.readFileSync('engineer-github-slack-mapping.json', 'utf8'));
            const engineerMap = new Map(
              engineerData.engineers.map(e => [e.github_username, e.slack_id])
            );
            
            /**
             * Fetch all activity data for a PR once
             */
            async function fetchPRActivity(owner, repo, prNumber) {
              try {
                const [commentsResponse, reviewsResponse, issueCommentsResponse] = await Promise.all([
                  github.rest.pulls.listReviewComments({ owner, repo, pull_number: prNumber }),
                  github.rest.pulls.listReviews({ owner, repo, pull_number: prNumber }),
                  github.rest.issues.listComments({ owner, repo, issue_number: prNumber })
                ]);
            
                return {
                  reviewComments: commentsResponse.data,
                  reviews: reviewsResponse.data,
                  issueComments: issueCommentsResponse.data
                };
              } catch (error) {
                console.error(`Error fetching activity for PR #${prNumber}:`, error.message);
                return {
                  reviewComments: [],
                  reviews: [],
                  issueComments: []
                };
              }
            }
            
            /**
             * Check if a user has been active on a PR in the last 3 days
             */
            function hasRecentActivity(activityData, username) {
              const now = Date.now();
              const thresholdDate = new Date(now - STALE_THRESHOLD_MS);
            
              const hasRecentReviewComment = activityData.reviewComments.some(comment => {
                return comment.user.login === username && 
                       new Date(comment.created_at) >= thresholdDate;
              });
            
              if (hasRecentReviewComment) return true;
            
              const hasRecentReview = activityData.reviews.some(review => {
                return review.user.login === username && 
                       new Date(review.submitted_at) >= thresholdDate;
              });
            
              if (hasRecentReview) return true;
            
              const hasRecentIssueComment = activityData.issueComments.some(comment => {
                return comment.user.login === username && 
                       new Date(comment.created_at) >= thresholdDate;
              });
            
              return hasRecentIssueComment;
            }
            
            /**
             * Send a Slack notification to remind a user to review a PR
             */
            async function sendReminder(username, prUrl, prTitle, channelId) {
              const slackId = engineerMap.get(username);
              
              if (!slackId) {
                console.log(`No Slack ID found for GitHub user: ${username}`);
                return;
              }
            
              try {
                await slack.chat.postMessage({
                  channel: channelId,
                  text: `⏰ Hey <@${slackId}>, you haven't reviewed this PR in the last 3 days:\n*${prTitle}*\n${prUrl}\n\nPlease take a look when you have a chance!`
                });
                console.log(`Sent reminder to ${username} (${slackId}) in channel ${channelId} for PR: ${prTitle}`);
              } catch (error) {
                console.error(`Failed to send Slack message to ${username}:`, error.message);
              }
            }
            
            /**
             * Get users to check for a PR based on assignees and reviewers
             */
            function getUsersToCheck(pr) {
              const usersToCheck = new Set();
            
              // For special users (ASSIGNEE_REVIEWERS), only check if they're assignees
              pr.assignees.forEach(assignee => {
                if (ASSIGNEE_REVIEWERS.has(assignee.login)) {
                  usersToCheck.add(assignee.login);
                }
              });
            
              // For everyone else, only check if they're requested reviewers
              pr.requested_reviewers.forEach(reviewer => {
                if (!ASSIGNEE_REVIEWERS.has(reviewer.login)) {
                  usersToCheck.add(reviewer.login);
                }
              });
            
              return Array.from(usersToCheck);
            }
            
            /**
             * Main function to check all PRs and send reminders
             */
            console.log('Starting PR review reminder check...');
            
            for (const { owner, repo, channel } of REPOS) {
              try {
                console.log(`\nChecking repository: ${owner}/${repo}`);
                
                const { data: prs } = await github.rest.pulls.list({
                  owner,
                  repo,
                  state: 'open'
                });
            
                console.log(`Found ${prs.length} open PR(s)`);
            
                for (const pr of prs) {
                  console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);
                  
                  // Skip PRs with 'Blocked' label
                  const hasBlockedLabel = pr.labels.some(label => label.name.toLowerCase() === 'blocked');
                  if (hasBlockedLabel) {
                    console.log('  ⛔ PR is labeled as "Blocked". Skipping...');
                    continue;
                  }
                  
                  const usersToCheck = getUsersToCheck(pr);
                  
                  if (usersToCheck.length === 0) {
                    console.log('  No users to check for this PR');
                    continue;
                  }
            
                  console.log(`  Checking users: ${usersToCheck.join(', ')}`);
            
                  // Fetch all activity data once for this PR
                  const activityData = await fetchPRActivity(owner, repo, pr.number);
            
                  for (const username of usersToCheck) {
                    const isActive = hasRecentActivity(activityData, username);
                    
                    if (!isActive) {
                      console.log(`  ⚠️ ${username} has been inactive for 3+ days`);
                      await sendReminder(username, pr.html_url, pr.title, channel);
                    } else {
                      console.log(`  ✓ ${username} has been active in the last 3 days`);
                    }
                  }
                }
              } catch (error) {
                console.error(`Error processing repository ${owner}/${repo}:`, error.message);
              }
            }
            
