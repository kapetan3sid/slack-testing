name: PR Review Reminder

on:
  schedule:
    # Run on weekdays at 9 AM UTC (Monday-Friday)
    - cron: '0 9 * * 1-5'
  workflow_dispatch: # Allow manual triggering

jobs:
  check-inactive-reviewers:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: npm install @slack/web-api

      - name: Check PRs and send reminders
        uses: actions/github-script@v7
        env:
          SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        with:
          script: |
            const { WebClient } = require('@slack/web-api');
            const fs = require('fs');
            
            const slack = new WebClient(process.env.SLACK_BOT_TOKEN);
            
            // Special users who are checked as ASSIGNEES instead of REVIEWERS
            const ASSIGNEE_REVIEWERS = new Set(['eshaben', 'dawnkelly09', '0xlukem', 'Telucero']);
            
            // Repositories to monitor
            // Check if today is a working day (Monday-Friday)
            const today = new Date();
            const dayOfWeek = today.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            
            if (dayOfWeek === 0 || dayOfWeek === 6) {
              console.log('Today is a weekend. Skipping PR review reminder check.');
              return;
            }
            
            // On Mondays, check for 4 days of inactivity (to cover the weekend)
            // On other weekdays, check for 3 days
            const isMonday = dayOfWeek === 1;
            const daysToCheck = isMonday ? 4 : 3;
            const STALE_THRESHOLD_MS = daysToCheck * 24 * 60 * 60 * 1000;
            
            console.log(`Today is ${['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][dayOfWeek]}`);
            console.log(`Checking for inactivity over the last ${daysToCheck} days`);
            
            const REPOS = [
              { owner: 'polkadot-developers', repo: 'polkadot-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'wormhole-foundation', repo: 'wormhole-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'kluster-ai', repo: 'docs', channel: 'C07TXJZ0T3L' },
              { owner: 'moondance-labs', repo: 'tanssi-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'moonbeam-foundation', repo: 'moonbeam-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'datahaven-xyz', repo: 'datahaven-docs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'kluster-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'polkadot-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'wormhole-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'datahaven-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'tanssi-mkdocs', channel: 'C07TXJZ0T3L' },
              { owner: 'papermoonio', repo: 'moonbeam-mkdocs', channel: 'C07TXJZ0T3L' }
            ];
            
            // Load engineer mappings
            const engineerData = JSON.parse(fs.readFileSync('engineer-github-slack-mapping.json', 'utf8'));
            const engineerMap = new Map(
              engineerData.engineers.map(e => [e.github_username, e.slack_id])
            );
            
            /**
             * Fetch all activity data for a PR once, including timeline for assignment events
             */
            async function fetchPRActivity(owner, repo, prNumber) {
              try {
                const [commentsResponse, reviewsResponse, issueCommentsResponse, timelineResponse] = await Promise.all([
                  github.rest.pulls.listReviewComments({ owner, repo, pull_number: prNumber }),
                  github.rest.pulls.listReviews({ owner, repo, pull_number: prNumber }),
                  github.rest.issues.listComments({ owner, repo, issue_number: prNumber }),
                  github.rest.issues.listEventsForTimeline({ owner, repo, issue_number: prNumber })
                ]);
            
                return {
                  reviewComments: commentsResponse.data,
                  reviews: reviewsResponse.data,
                  issueComments: issueCommentsResponse.data,
                  timeline: timelineResponse.data
                };
              } catch (error) {
                console.error(`Error fetching activity for PR #${prNumber}:`, error.message);
                return {
                  reviewComments: [],
                  reviews: [],
                  issueComments: [],
                  timeline: []
                };
              }
            }
            
            /**
             * Get when a user was assigned or requested for review
             */
            function getAssignmentDate(timeline, username, isAssignee) {
              // Look for assignment/review_requested events in timeline
              const eventType = isAssignee ? 'assigned' : 'review_requested';
              
              // Find the most recent assignment event for this user
              const assignmentEvent = timeline
                .filter(event => {
                  if (event.event === eventType) {
                    if (isAssignee) {
                      return event.assignee?.login === username;
                    } else {
                      return event.requested_reviewer?.login === username;
                    }
                  }
                  return false;
                })
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];
              
              return assignmentEvent ? new Date(assignmentEvent.created_at) : null;
            }
            
            /**
             * Check if a user has been active on a PR in the last 3 days
             */
            function hasRecentActivity(activityData, username) {
              const now = Date.now();
              const thresholdDate = new Date(now - STALE_THRESHOLD_MS);
            
              const hasRecentReviewComment = activityData.reviewComments.some(comment => {
                return comment.user.login === username && 
                       new Date(comment.created_at) >= thresholdDate;
              });
            
              if (hasRecentReviewComment) return true;
            
              const hasRecentReview = activityData.reviews.some(review => {
                return review.user.login === username && 
                       new Date(review.submitted_at) >= thresholdDate;
              });
            
              if (hasRecentReview) return true;
            
              const hasRecentIssueComment = activityData.issueComments.some(comment => {
                return comment.user.login === username && 
                       new Date(comment.created_at) >= thresholdDate;
              });
            
              return hasRecentIssueComment;
            }
            
            /**
             * Send a Slack notification to remind a user to review a PR
             */
            async function sendReminder(username, prUrl, prTitle, channelId) {
              const slackId = engineerMap.get(username);
              
              if (!slackId) {
                console.log(`No Slack ID found for GitHub user: ${username}`);
                return;
              }
            
              try {
                await slack.chat.postMessage({
                  channel: channelId,
                  text: `‚è∞ Hey <@${slackId}>, just a quick reminder that this PR hasn't been reviewed in the last 3 days:\n*${prTitle}*\n${prUrl}\n\nPlease take a look when you have a chance!`
                });
                console.log(`Sent reminder to ${username} (${slackId}) in channel ${channelId} for PR: ${prTitle}`);
              } catch (error) {
                console.error(`Failed to send Slack message to ${username}:`, error.message);
              }
            }
            
            /**
             * Get users to check for a PR based on assignees and reviewers
             * Returns array of objects with username and isAssignee flag
             */
            function getUsersToCheck(pr) {
              const usersToCheck = [];
            
              // For special users (ASSIGNEE_REVIEWERS), only check if they're assignees
              pr.assignees.forEach(assignee => {
                if (ASSIGNEE_REVIEWERS.has(assignee.login)) {
                  usersToCheck.push({ username: assignee.login, isAssignee: true });
                }
              });
            
              // For everyone else, only check if they're requested reviewers
              pr.requested_reviewers.forEach(reviewer => {
                if (!ASSIGNEE_REVIEWERS.has(reviewer.login)) {
                  usersToCheck.push({ username: reviewer.login, isAssignee: false });
                }
              });
            
              return usersToCheck;
            }
            
            /**
             * Main function to check all PRs and send reminders
             */
            console.log('Starting PR review reminder check...');
            
            for (const { owner, repo, channel } of REPOS) {
              try {
                console.log(`\nChecking repository: ${owner}/${repo}`);
                
                const { data: prs } = await github.rest.pulls.list({
                  owner,
                  repo,
                  state: 'open'
                });
            
                console.log(`Found ${prs.length} open PR(s)`);
            
                for (const pr of prs) {
                  console.log(`\nProcessing PR #${pr.number}: ${pr.title}`);
                  
                  // Skip draft PRs
                  if (pr.draft) {
                    console.log('  üìù PR is a draft. Skipping...');
                    continue;
                  }
                  
                  // Skip PRs that are younger than the threshold
                  const prAge = Date.now() - new Date(pr.created_at).getTime();
                  if (prAge < STALE_THRESHOLD_MS) {
                    const ageInDays = Math.floor(prAge / (24 * 60 * 60 * 1000));
                    console.log(`  üÜï PR is only ${ageInDays} day(s) old. Skipping...`);
                    continue;
                  }
                  
                  // Skip PRs with 'Blocked' label (e.g., "B2 - Blocked")
                  const hasBlockedLabel = pr.labels.some(label => label.name.toLowerCase().includes('blocked'));
                  if (hasBlockedLabel) {
                    console.log('  ‚õî PR is labeled as "Blocked". Skipping...');
                    continue;
                  }
                  
                  const usersToCheck = getUsersToCheck(pr);
                  
                  if (usersToCheck.length === 0) {
                    console.log('  No users to check for this PR');
                    continue;
                  }
            
                  const usernames = usersToCheck.map(u => u.username).join(', ');
                  console.log(`  Checking users: ${usernames}`);
            
                  // Fetch all activity data once for this PR
                  const activityData = await fetchPRActivity(owner, repo, pr.number);
            
                  for (const userInfo of usersToCheck) {
                    const { username, isAssignee } = userInfo;
                    
                    // Check when the user was assigned/requested
                    const assignmentDate = getAssignmentDate(activityData.timeline, username, isAssignee);
                    
                    if (!assignmentDate) {
                      console.log(`  ‚ö†Ô∏è Could not find assignment date for ${username}. Skipping...`);
                      continue;
                    }
                    
                    const assignmentAge = Date.now() - assignmentDate.getTime();
                    
                    // Check if user has been assigned for at least 3 days (or 4 on Mondays)
                    if (assignmentAge < STALE_THRESHOLD_MS) {
                      const ageInDays = Math.floor(assignmentAge / (24 * 60 * 60 * 1000));
                      console.log(`  ‚ÑπÔ∏è ${username} was assigned only ${ageInDays} day(s) ago. Skipping...`);
                      continue;
                    }
                    
                    // Check if user has been active in the last 3 days (or 4 on Mondays)
                    const isActive = hasRecentActivity(activityData, username);
                    
                    if (!isActive) {
                      console.log(`  ‚ö†Ô∏è ${username} has been assigned for 3+ days and inactive. Sending reminder...`);
                      await sendReminder(username, pr.html_url, pr.title, channel);
                    } else {
                      console.log(`  ‚úì ${username} has been active in the last 3 days`);
                    }
                  }
                }
              } catch (error) {
                console.error(`Error processing repository ${owner}/${repo}:`, error.message);
              }
            }
            
